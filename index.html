<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<title>Commander Threat Counter v1.3</title>

<style>
:root{
  --bg:#000;
  --panel:#101820;
  --panel2:#1b2533;
  --btn:#1f2a3a;
  --btn2:#223046;
  --text:#fff;
  --muted:rgba(255,255,255,.75);
  --border:rgba(255,255,255,.08);
  --threat:#baff2a;
}

body{
  margin:0;
  background:var(--bg);
  font-family:-apple-system, BlinkMacSystemFont, sans-serif;
  color:var(--text);
  -webkit-tap-highlight-color: transparent;
}

.top-section{
  text-align:center;
  padding:10px 6px 4px 6px;
}

.logo{
  font-size:20px;
  font-weight:800;
}

.ad-banner{
  margin-top:6px;
  font-size:12px;
  background:#111;
  padding:6px;
  border-radius:6px;
}

.grid{
  display:grid;
  grid-template-columns:1fr 1fr;
  grid-template-rows:1fr 1fr;
  height:calc(100vh - 110px);
  gap:4px;
  padding:4px;
}

.player{
  background:var(--panel);
  border-radius:12px;
  padding:6px;
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  border:1px solid var(--border);
  transition:transform .2s ease, box-shadow .2s ease, border .2s ease;
  position:relative;
  overflow:hidden;
}

.player.threat{
  box-shadow:0 0 16px #baff2a88, 0 0 30px #ffe94a66;
  border:2px solid var(--threat);
}

.player.rotated{
  transform: rotate(180deg);
}

.header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:6px;
}

.name{
  font-weight:700;
  font-size:12px;
  cursor:pointer;
  user-select:none;
}

.headerRight{
  display:flex;
  gap:6px;
  align-items:center;
}

select{
  background:#1e293b;
  border:none;
  color:white;
  padding:2px 4px;
  border-radius:6px;
  font-size:10px;
}

.iconBtn{
  width:28px;
  flex:0 0 auto;
  padding:6px 0;
  font-size:14px;
  line-height:14px;
  border-radius:8px;
  background:var(--btn);
}

.life{
  text-align:center;
  font-size:38px;
  font-weight:900;
  user-select:none;
}

.tapToEditHint{
  text-align:center;
  font-size:9px;
  color:rgba(255,255,255,.55);
  margin-top:-4px;
  user-select:none;
}

.valueTap{
  cursor:pointer;
  user-select:none;
}

.controls{
  display:flex;
  justify-content:space-between;
}

button{
  flex:1;
  margin:1px;
  border:none;
  border-radius:8px;
  padding:6px 0;
  font-size:14px;
  font-weight:700;
  background:var(--btn);
  color:var(--text);
}

button:active{
  transform: scale(0.98);
}

.stats{
  font-size:10px;
}

.statRow{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:6px;
  padding:1px 0;
}

.statLabel{
  color:var(--muted);
}

.smallBtn{
  font-size:10px;
  padding:2px 6px;
  margin-left:2px;
  border-radius:6px;
  flex:0 0 auto;
}

.cmdBtn{
    
  padding:4px 0;
  font-size:11px;
  background:rgba(255,255,255,0.05);
  border:1px solid rgba(255,255,255,0.08);
  border-radius:8px;
  height:26px;
  line-height:18px;
margin-top:3px;
}

.modal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.85);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1000;
}

.modalContent{
  background:var(--panel2);
  padding:14px;
  border-radius:12px;
  width:92%;
  max-width:380px;
  border:1px solid rgba(255,255,255,.12);
}

.modalTitle{
  font-size:16px;
  font-weight:800;
  margin:0 0 8px 0;
}

.modalRow{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin:8px 0;
  gap:10px;
}

.modalRowLeft{
  display:flex;
  flex-direction:column;
  gap:2px;
  min-width:0;
}

.modalRowLabel{
  font-size:12px;
  font-weight:700;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

.modalRowSub{
  font-size:10px;
  color:rgba(255,255,255,.65);
}

.modalRowRight{
  display:flex;
  align-items:center;
  gap:6px;
}

.modalValue{
  font-size:14px;
  font-weight:900;
  min-width:28px;
  text-align:right;
}

.modalFooter{
  display:flex;
  gap:8px;
  margin-top:12px;
}

.modalFooter button{
  padding:10px 0;
}

.input{
  width:100%;
  box-sizing:border-box;
  background:#0f172a;
  color:var(--text);
  border:1px solid rgba(255,255,255,.15);
  border-radius:10px;
  padding:10px 12px;
  font-size:16px;
  outline:none;
}

.zoomBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  z-index:900;
}

.player.zoomed{
  position:fixed;
  inset:8px;
  width:auto !important;
  height:auto !important;
  z-index:950;
  border-radius:16px;
  padding:12px;
}

.zoomControls{
  display:none;
  position:absolute;
  top:8px;
  right:8px;
  gap:8px;
}

.player.zoomed .zoomControls{
  display:flex;
}

.zoomControls button{
  width:auto;
  flex:0 0 auto;
  padding:10px 12px;
  font-size:14px;
  border-radius:12px;
}

.zoomClose{
  background:#2a1f1f;
}

.zoomRotate{
  background:#1f2a3a;
}
</style>
</head>

<body>

<div class="top-section">
  <div class="logo">YOUR BUSINESS LOGO</div>
  <div class="ad-banner">
  Advertising Banner Space â€¢ <span id="wakeStatus" style="margin-left:8px; cursor:pointer;">ðŸ”’ Awake: OFF</span>
</div>
</div>

<div class="grid" id="grid"></div>

<div class="zoomBackdrop" id="zoomBackdrop" onclick="unzoom()"></div>

<!-- Commander Damage Modal -->
<div class="modal" id="cmdModal" onclick="modalBackdropClose(event, 'cmdModal')">
  <div class="modalContent" id="cmdContent"></div>
</div>

<!-- Generic Edit Modal (Name / Number) -->
<div class="modal" id="editModal" onclick="modalBackdropClose(event, 'editModal')">
  <div class="modalContent" id="editContent"></div>
</div>

<script>
const START = { life:40, cards:7, permanents:0, mana:0, poison:0 };

let players = [];
let heat = [0,0,0,0];
let lastThreat = null;
let zoomedIndex = null;

function createPlayer(index){
  return {
    id:index,
    name:"Seat "+(index+1),
    archetype:"Aggro",
    life:START.life,
    cards:START.cards,
    permanents:START.permanents,
    mana:START.mana,
    poison:START.poison,
    // Commander damage taken by this player from each seat (including self for completeness)
    cmd:[0,0,0,0],
    rotated:false
  };
}

for(let i=0;i<4;i++){ players.push(createPlayer(i)); }

function clampInt(v, min, max){
  v = parseInt(v, 10);
  if (Number.isNaN(v)) return min;
  return Math.max(min, Math.min(max, v));
}

function computeThreat(){
  let avgLife = players.reduce((a,p)=>a+p.life,0)/4;
  let avgCards = players.reduce((a,p)=>a+p.cards,0)/4;
  let avgMana = players.reduce((a,p)=>a+p.mana,0)/4;
  let avgPerm = players.reduce((a,p)=>a+p.permanents,0)/4;

  const wL=0.20, wC=1.0, wM=1.3, wP=0.8;
  const alpha=0.75, gamma=0.25;

  const speedAxis = { Aggro:1.0, Combo:1.2, Midrange:0.5, Control:0.0 };

  let archetypeCounts={Aggro:0,Combo:0,Midrange:0,Control:0};
  players.forEach(p=>archetypeCounts[p.archetype]++);

  let scores=[];

  players.forEach((p,i)=>{
    let URS = wL*(p.life-avgLife)
            + wC*(p.cards-avgCards)
            + wM*(p.mana-avgMana)
            + wP*(p.permanents-avgPerm);

    let LD = p.life/40;
    let PD = (10-p.poison)/10;
    let CD = 1;

    // Commander damage compression: the lowest remaining threshold among opponents
    for(let j=0;j<4;j++){
      if(j!==i){
        CD=Math.min(CD,(21-p.cmd[j])/21);
      }
    }

    let TCI = 1-Math.min(LD,PD,CD);
    let base = alpha*URS + gamma*TCI;

    let nT = archetypeCounts[p.archetype];
    let minorityFactor = 1 - 0.18*((3-nT)/3);

    let seatMultiplier = 1 + 0.08*speedAxis[p.archetype]*((3-i)/3);

    let infoBonus=1;
    if(p.archetype==="Control"){
      infoBonus = 1 + 0.05*(i/3);
    }

    let score = base*minorityFactor*seatMultiplier*infoBonus*(1-heat[i]);
    scores.push(score);
  });

  let max=Math.max(...scores);
  let newThreat=scores.indexOf(max);

  if(lastThreat!==null){
    if(scores[newThreat] < scores[lastThreat]*1.08){
      newThreat=lastThreat;
    }
  }

  players.forEach((p,i)=>{
    if(i===newThreat){
      heat[i]=Math.min(.35,heat[i]+.03);
    }else{
      heat[i]=Math.max(0,heat[i]-.02);
    }
  });

  lastThreat=newThreat;
  players.forEach((p,i)=>p.isThreat=(i===newThreat));
}

function render(){
  computeThreat();
  const grid=document.getElementById("grid");
  grid.innerHTML="";

  players.forEach((p,i)=>{
    let div=document.createElement("div");
    div.className="player"+(p.isThreat?" threat":"")+(p.rotated?" rotated":"");
    div.dataset.playerIndex = i;

    // Click-to-zoom: only when tapping non-interactive space
    div.addEventListener("click",(e)=>{
      const interactive = e.target.closest("button, select, .name, .valueTap, input");
      if(interactive) return;
      zoomPlayer(i);
    });

    div.innerHTML=`
      <div class="zoomControls">
        <button class="zoomRotate" onclick="toggleRotate(${i}); event.stopPropagation();">ðŸ”„ Rotate</button>
        <button class="zoomClose" onclick="unzoom(); event.stopPropagation();">âœ• Close</button>
      </div>

      <div class="header">
        <div class="name" onclick="editName(${i}); event.stopPropagation();">${escapeHtml(p.name)}</div>
        <div class="headerRight">
          <button class="iconBtn" title="Rotate player space" onclick="toggleRotate(${i}); event.stopPropagation();">ðŸ”„</button>
          <select onchange="setArch(${i},this.value); event.stopPropagation();">
            <option ${p.archetype==="Aggro"?"selected":""}>Aggro</option>
            <option ${p.archetype==="Combo"?"selected":""}>Combo</option>
            <option ${p.archetype==="Midrange"?"selected":""}>Midrange</option>
            <option ${p.archetype==="Control"?"selected":""}>Control</option>
          </select>
        </div>
      </div>

      <div class="life valueTap" onclick="editNumber(${i}, 'life', 'Life', 0, 999); event.stopPropagation();">${p.life}</div>
      <div class="tapToEditHint">Tap number to set â€¢ Use +/- to adjust</div>

      <div class="controls">
        <button onclick="adjust(${i},-1); event.stopPropagation();">-</button>
        <button onclick="adjust(${i},1); event.stopPropagation();">+</button>
      </div>

      <div class="stats">
        ${statRow(i,"Cards","cards",0,999)}
        ${statRow(i,"Mana","mana",0,999)}
        ${statRow(i,"Perm","permanents",0,999)}
        ${statRow(i,"Poison","poison",0,10)}
      </div>

      <button class="cmdBtn" onclick="openCmd(${i}); event.stopPropagation();">Commander Damage</button>
    `;

    grid.appendChild(div);
  });

  // Re-apply zoomed class to the same element after re-render
  if(zoomedIndex !== null){
    const node = [...document.querySelectorAll(".player")].find(el => parseInt(el.dataset.playerIndex,10)===zoomedIndex);
    if(node){
      node.classList.add("zoomed");
      document.getElementById("zoomBackdrop").style.display="block";
    }else{
      zoomedIndex = null;
      document.getElementById("zoomBackdrop").style.display="none";
    }
  }
}

function statRow(i,label,stat,min,max){
  return `
    <div class="statRow">
      <div class="statLabel">${label}:</div>
      <div class="valueTap" onclick="editNumber(${i}, '${stat}', '${label}', ${min}, ${max}); event.stopPropagation();">${players[i][stat]}</div>
      <span>
        <button class="smallBtn" onclick="statAdjust(${i},'${stat}',-1, ${min}, ${max}); event.stopPropagation();">-</button>
        <button class="smallBtn" onclick="statAdjust(${i},'${stat}',1, ${min}, ${max}); event.stopPropagation();">+</button>
      </span>
    </div>
  `;
}

function zoomPlayer(i){
  zoomedIndex = i;
  document.getElementById("zoomBackdrop").style.display="block";
  render();
}

function unzoom(){
  zoomedIndex = null;
  document.getElementById("zoomBackdrop").style.display="none";
  // Remove zoomed class from any lingering nodes
  document.querySelectorAll(".player.zoomed").forEach(n=>n.classList.remove("zoomed"));
}

function toggleRotate(i){
  players[i].rotated = !players[i].rotated;
  render();
}

function openCmd(i){
  let modal=document.getElementById("cmdModal");
  let content=document.getElementById("cmdContent");

  content.innerHTML = `
    <div class="modalTitle">Commander Damage Taken</div>
    <div style="font-size:11px; color:rgba(255,255,255,.65); margin-bottom:8px;">
      Editing: <b>${escapeHtml(players[i].name)}</b>
    </div>
  `;

  // Show all 4 players (including self), labels auto-populate from name field.
  for(let j=0;j<4;j++){
    const isSelf = (j===i);
    const label = players[j].name;
    const value = players[i].cmd[j] || 0;

    content.innerHTML += `
      <div class="modalRow" style="${isSelf ? "opacity:.45;" : ""}">
        <div class="modalRowLeft">
          <div class="modalRowLabel">${escapeHtml(label)}</div>
          <div class="modalRowSub">${isSelf ? "Self (disabled)" : "Damage from this commander"}</div>
        </div>
        <div class="modalRowRight">
          <div class="modalValue valueTap" onclick="${isSelf ? "" : `editCmdValue(${i},${j});`} event.stopPropagation();">${value}</div>
          <button class="smallBtn" ${isSelf ? "disabled" : ""} onclick="cmdAdjust(${i},${j},-1); event.stopPropagation();">-</button>
          <button class="smallBtn" ${isSelf ? "disabled" : ""} onclick="cmdAdjust(${i},${j},1); event.stopPropagation();">+</button>
        </div>
      </div>
    `;
  }

  content.innerHTML += `
    <div class="modalFooter">
      <button onclick="closeCmd()">Close</button>
    </div>
  `;

  modal.style.display="flex";
}

function closeCmd(){
  document.getElementById("cmdModal").style.display="none";
  render();
}

function cmdAdjust(i,j,val){
  if(i===j) return; // self disabled
  let newVal = clampInt((players[i].cmd[j]||0) + val, 0, 21);
  let diff = newVal - (players[i].cmd[j]||0);
  players[i].cmd[j] = newVal;

  // Keep existing behavior: when commander damage increases, reduce life by same amount.
  // Note: this is a convenience coupling; you can disable if you want commander damage tracked separately.
  if(diff > 0){
    players[i].life = Math.max(0, players[i].life - diff);
  }

  openCmd(i);
}

function editCmdValue(i,j){
  openEditModal({
    title: `Set Commander Damage`,
    subtitle: `Target: <b>${escapeHtml(players[i].name)}</b><br/>Source: <b>${escapeHtml(players[j].name)}</b>`,
    type: "number",
    value: players[i].cmd[j] || 0,
    min: 0,
    max: 21,
    onSave: (v)=>{
      v = clampInt(v, 0, 21);
      const diff = v - (players[i].cmd[j]||0);
      players[i].cmd[j] = v;
      if(diff > 0){
        players[i].life = Math.max(0, players[i].life - diff);
      }
      openCmd(i);
    }
  });
}

function adjust(i,val){
  players[i].life = Math.max(0, players[i].life + val);
  render();
}

function statAdjust(i,stat,val,min,max){
  players[i][stat] = clampInt(players[i][stat] + val, min, max);
  render();
}

function editName(i){
  openEditModal({
    title: "Edit Player Name",
    subtitle: "Updates commander-damage labels automatically.",
    type: "text",
    value: players[i].name,
    onSave: (v)=>{
      v = (v || "").trim();
      if(v.length === 0) return;
      players[i].name = v;
      closeEdit();
      render();
    }
  });
}

function editNumber(i, stat, label, min, max){
  openEditModal({
    title: `Set ${label}`,
    subtitle: `Player: <b>${escapeHtml(players[i].name)}</b>`,
    type: "number",
    value: players[i][stat],
    min,
    max,
    onSave: (v)=>{
      players[i][stat] = clampInt(v, min, max);
      closeEdit();
      render();
    }
  });
}

function setArch(i,val){
  players[i].archetype = val;
  render();
}

function modalBackdropClose(e, id){
  if(e.target && e.target.id === id){
    document.getElementById(id).style.display="none";
    if(id === "cmdModal") render();
  }
}

function openEditModal({title, subtitle, type, value, min, max, onSave}){
  const modal = document.getElementById("editModal");
  const content = document.getElementById("editContent");

  const isNumber = type === "number";
  const inputAttrs = isNumber
    ? `inputmode="numeric" pattern="[0-9]*" min="${min ?? 0}" max="${max ?? 999}"`
    : `autocomplete="off"`;

  content.innerHTML = `
    <div class="modalTitle">${title}</div>
    <div style="font-size:11px; color:rgba(255,255,255,.7); margin-bottom:10px;">${subtitle || ""}</div>
    <input class="input" id="editInput" type="${type}" ${inputAttrs} value="${escapeAttr(String(value ?? ""))}" />
    <div class="modalFooter">
      <button onclick="saveEdit()">Save</button>
      <button onclick="closeEdit()">Cancel</button>
    </div>
  `;

  modal.style.display = "flex";

  window.__editSave = onSave;
  setTimeout(()=>{
    const el = document.getElementById("editInput");
    if(el){
      el.focus();
      if(!isNumber) el.select();
    }
  }, 30);
}

function saveEdit(){
  const el = document.getElementById("editInput");
  if(!el || !window.__editSave) return;
  window.__editSave(el.value);
}

function closeEdit(){
  document.getElementById("editModal").style.display="none";
  window.__editSave = null;
}

function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function escapeAttr(str){
  // conservative: same as HTML escape
  return escapeHtml(str);
}

/* ===============================
   SCREEN WAKE LOCK IMPLEMENTATION
   =============================== */

let wakeLock = null;
let wakeEnabled = true;

function setWakeStatus(text){
  const el = document.getElementById("wakeStatus");
  if(el) el.innerText = text;
}

async function requestWakeLock() {
  try {
    if ('wakeLock' in navigator && wakeEnabled) {
      wakeLock = await navigator.wakeLock.request('screen');
      setWakeStatus("ðŸ”’ Awake: ON");
      wakeLock.addEventListener('release', () => {
        setWakeStatus("ðŸ”’ Awake: OFF");
      });
    } else {
      // Unsupported (common on iOS Safari depending on version)
      setWakeStatus("ðŸ”’ Awake: UNSUP");
    }
  } catch (err) {
    console.log("Wake Lock Error:", err);
    setWakeStatus("ðŸ”’ Awake: OFF");
  }
}

async function releaseWakeLock() {
  try {
    if (wakeLock !== null) {
      await wakeLock.release();
      wakeLock = null;
    }
  } catch (err) {
    console.log("Wake Lock Release Error:", err);
  } finally {
    setWakeStatus("ðŸ”’ Awake: OFF");
  }
}

async function toggleWakeLock() {
  wakeEnabled = !wakeEnabled;
  if (wakeEnabled) {
    await requestWakeLock();
  } else {
    await releaseWakeLock();
  }
}

// Toggle by tapping the indicator
document.addEventListener("DOMContentLoaded", () => {
  const el = document.getElementById("wakeStatus");
  if(el){
    el.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleWakeLock();
    });
  }
});

// Reacquire when returning to the tab
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && wakeEnabled) {
    requestWakeLock();
  }
});

// Browsers typically require a user gesture to start
document.addEventListener('click', () => {
  if (!wakeLock && wakeEnabled) requestWakeLock();
}, { once: true });

render();
</script>
</body>
</html>
